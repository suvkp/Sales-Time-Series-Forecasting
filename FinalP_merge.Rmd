---
title: "FinalProject"
author: "Britt Roele"
date: "12/5/2021"
output: pdf_document
---



```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)

library(fpp3)
library(dplyr)
library(tsibble)
library(lubridate)
library(ggplot2)
library(dtwclust)


```

# Data exploring

```{r}
#reading the data
calendar <- read.csv("calendar_afcs2021.csv")
train <- read.csv("sales_train_validation_afcs2021.csv")
test <- read.csv("sales_test_validation_afcs2021.csv")
sale_prices <- read.csv("sell_prices_afcs2021.csv")

# Transpose function
transpose <- function(df) {
  tdf <- t(df)
  col <- df[,1]
  tdf <- as.data.frame(tdf[-1,]) 
  colnames(tdf) <- col  
  tdf <- as.data.frame(tdf)
}

# Transposing the train and test set to obtain data in the desired format
trainT <- transpose(train);trainT
#trainT <- tibble::rownames_to_column(trainT, "d")

testT <- transpose(test)
#testT <- tibble::rownames_to_column(testT, "d")

# Make data numeric
nm <- colnames(trainT)
nm <- nm[-1]
for(cols in nm){
  trainT[,cols] <- as.numeric(trainT[,cols])
}

#get all columns that are of type factor
factor_columns <- sapply(trainT, is.factor)

#change them from type factor to numeric so the numeric data can be plotted 
trainT[factor_columns] <- lapply(trainT[factor_columns], function(x) as.numeric(as.character(x))) 
# add d to columns
trainT <- tibble::rownames_to_column(trainT, "d")

# Merge with calendar
train_new <- merge(calendar, trainT, by = "d")

# Only keep the date of the calendar dataframe into the new dataframe
trainNew = subset(train_new, select = -c(wm_yr_wk,weekday, wday,month,year,event_name_1, event_type_1,event_name_2,event_type_2,snap_CA) )

# Changing character date as date type
trainNew$date <- mdy(trainNew$date)


# Set d as index
rownames(trainNew) <- trainNew$d
trainNew <- subset(trainNew, select= -c(d))

trainNew <- na.omit(trainNew)
trainNew

#get all columns that are of type factor
factor_columns <- sapply(trainNew, is.factor)

#change them from type factor to numeric so the numeric data can be plotted 
trainNew[factor_columns] <- lapply(trainNew[factor_columns], function(x) as.numeric(as.character(x))) 
```

```{r}
#prepare the data to be clustered (removing the date column)
#cluster_data <- t(trainNew[(- ncol(trainNew)),]); cluster_data
cluster_data <- subset(trainNew, select = -c(date)); cluster_data

#save all the dates of the training data
train_dates <- trainNew[1]; train_dates

# transpose data so the products will be clusters instead of the dates
cluster_data <- tibble::rownames_to_column(cluster_data, "d"); cluster_data
cluster_data <- transpose(cluster_data);cluster_data


clusters <- tsclust(cluster_data, type = "partitional", k = 10L, 
              distance = "dtw_basic", centroid = "pam", 
              seed = 3247L, trace = TRUE,
              args = tsclust_args(dist = list(window.size = 10L)))

#plotting the clusters 
plot(clusters)
```


```{r}
#saving the clusters 
cluster <- clusters@cluster

#add the corresponding cluster to the data 
train_cluster_set <- cbind(cluster_data,cluster)

# Make the different clusters as df
cluster1 <- train_cluster_set %>% filter(cluster == 1)
cluster2 <- train_cluster_set %>% filter(cluster == 2)
cluster3 <- train_cluster_set %>% filter(cluster == 3)
cluster4 <- train_cluster_set %>% filter(cluster == 4)
cluster5 <- train_cluster_set %>% filter(cluster == 5)
cluster6 <- train_cluster_set %>% filter(cluster == 6)
cluster7 <- train_cluster_set %>% filter(cluster == 7)
cluster8 <- train_cluster_set %>% filter(cluster == 8)
cluster9 <- train_cluster_set %>% filter(cluster == 9)
cluster10 <- train_cluster_set %>% filter(cluster == 10)

# Give each month of the year an unique id
calendar <- calendar %>%
 group_by(year, month) %>%
 mutate(group_id = cur_group_id())

# Merge calendar with cluster
c1 <- tibble::rownames_to_column(cluster1, "Products")
c1 <- transpose(c1)
c1 <- tibble::rownames_to_column(c1, "d")
test1 <- merge(c1, calendar, by = "d")
test1

# Merge calendar with cluster
c2 <- tibble::rownames_to_column(cluster2, "Products")
c2 <- transpose(c2)
c2 <- tibble::rownames_to_column(c2, "d")
test2 <- merge(c2, calendar, by = "d")
test2

# Merge calendar with cluster
c3 <- tibble::rownames_to_column(cluster3, "Products")
c3 <- transpose(c3)
c3 <- tibble::rownames_to_column(c3, "d")
test3 <- merge(c3, calendar, by = "d")
test3

# Merge calendar with cluster
c4 <- tibble::rownames_to_column(cluster4, "Products")
c4 <- transpose(c4)
c4 <- tibble::rownames_to_column(c4, "d")
test4 <- merge(c4, calendar, by = "d")
test4

# Merge calendar with cluster
c5 <- tibble::rownames_to_column(cluster5, "Products")
c5 <- transpose(c5)
c5 <- tibble::rownames_to_column(c5, "d")
test5 <- merge(c5, calendar, by = "d")
test5

# Merge calendar with cluster
c6 <- tibble::rownames_to_column(cluster6, "Products")
c6 <- transpose(c6)
c6 <- tibble::rownames_to_column(c6, "d")
test6 <- merge(c6, calendar, by = "d")
test6

# Merge calendar with cluster
c7 <- tibble::rownames_to_column(cluster7, "Products")
c7 <- transpose(c7)
c7 <- tibble::rownames_to_column(c7, "d")
test7 <- merge(c7, calendar, by = "d")
test7

# Merge calendar with cluster
c8 <- tibble::rownames_to_column(cluster8, "Products")
c8 <- transpose(c8)
c8 <- tibble::rownames_to_column(c8, "d")
test8 <- merge(c8, calendar, by = "d")
test8

# Merge calendar with cluster
c9 <- tibble::rownames_to_column(cluster9, "Products")
c9 <- transpose(c9)
c9 <- tibble::rownames_to_column(c9, "d")
test9 <- merge(c9, calendar, by = "d")
test9

# Merge calendar with cluster
c10 <- tibble::rownames_to_column(cluster10, "Products")
c10 <- transpose(c10)
c10 <- tibble::rownames_to_column(c10, "d")
test10 <- merge(c10, calendar, by = "d")
test10

```


# Modelling


# Cluster 1
```{r}
# Get the number of events per month per year
event1 <- test1 %>%
  select(year, month, event_name_1, event_type_1, event_name_2, event_type_2) %>%
  mutate(
    event = if_else((event_name_1 != "" | event_type_1 != "" | event_name_2 != "" | event_type_2 != ""), 1, 0)
  ) %>%
  group_by(year, month) %>%
  summarise(event = sum(event))

# Keep certain columns
newC1 <- subset(test1, select = -c(date,wm_yr_wk,weekday,wday,event_name_1, event_type_1,event_name_2,event_type_2, snap_CA))
NC1 <- merge(newC1, event1);NC1
NC1 <- subset(NC1, select=-c(month, year, group_id))

# Make an event data frame
events <- subset(NC1, select=event);events
events <- tibble::rownames_to_column(events, "d")

# Keep only the products
NC1 <- subset(NC1, select=-c(event));NC1
rownames(NC1) <- NC1$d
NC1 <- subset(NC1, select = -c(d));NC1

#get all columns that are of type character
factor_columns <- sapply(NC1, is.character)

#change them from type factor to numeric so the numeric data can be plotted 
NC1[factor_columns] <- lapply(NC1[factor_columns], function(x) as.numeric(as.character(x))) 

# Get the mean of sales per day
train1 <- NC1 %>% mutate('rowMean' = rowMeans(NC1))
train1 <- subset(train1, select = rowMean)

tr1 <- tibble::rownames_to_column(train1, "d"); tr1

#get all columns that are of type character
factor_columns <- sapply(tr1, is.character)

#change them from type factor to numeric so the numeric data can be plotted 
tr1[factor_columns] <- lapply(tr1[factor_columns], function(x) as.numeric(as.character(x)))

# Add events to the rowMeans
tr1 <- merge(tr1, events, by="d"); tr1

# Make a tsibble of the data frame
tr1 <- tr1 %>%
  as_tsibble(
    index = d
    )

# Plot
tr1 %>% autoplot(rowMean)

# Fit the training data
fit <- tr1 %>% 
  model(
    trend_model = TSLM(rowMean ~ trend()),
    MEAN = MEAN(rowMean),
    NAIVE = NAIVE(rowMean),
    SNAIVE = SNAIVE(rowMean),
    Drift = RW(rowMean ~ drift()),
    arima = ARIMA(rowMean)
  )

# Get the accuracy
fit %>% accuracy()

```

# Get the products of cluster 1
Best model for cluster1 is ARIMA model.
```{r}
# Get the products from cluster 1
new <- transpose(NC1)
products1 <- tibble::rownames_to_column(new, "Products")
products1 <- products1['Products']; products1

```

# Cluster 2
```{r}
# Get the number of events per month per year
event2 <- test2 %>%
  select(year, month, event_name_1, event_type_1, event_name_2, event_type_2) %>%
  mutate(
    event = if_else((event_name_1 != "" | event_type_1 != "" | event_name_2 != "" | event_type_2 != ""), 1, 0)
  ) %>%
  group_by(year, month) %>%
  summarise(event = sum(event))

# Keep certain columns
newC2 <- subset(test2, select = -c(date,wm_yr_wk,weekday,wday,event_name_1, event_type_1,event_name_2,event_type_2, snap_CA))
NC2 <- merge(newC2, event2);NC2
NC2 <- subset(NC2, select=-c(month, year, group_id))

# Make an event data frame
events <- subset(NC2, select=event);events
events <- tibble::rownames_to_column(events, "d")

# Keep only the products
NC2 <- subset(NC2, select=-c(event))
rownames(NC2) <- NC2$d
NC2 <- subset(NC2, select = -c(d))

#get all columns that are of type character
factor_columns <- sapply(NC2, is.character)

#change them from type factor to numeric so the numeric data can be plotted 
NC2[factor_columns] <- lapply(NC2[factor_columns], function(x) as.numeric(as.character(x))) 

# Get the mean of sales per day
train2 <- NC2 %>% mutate('rowMean' = rowMeans(NC2))
train2 <- subset(train2, select = rowMean)

tr2 <- tibble::rownames_to_column(train2, "d")

#get all columns that are of type character
factor_columns <- sapply(tr2, is.character)

#change them from type factor to numeric so the numeric data can be plotted 
tr2[factor_columns] <- lapply(tr2[factor_columns], function(x) as.numeric(as.character(x)))

# Add events to the rowMeans
tr2 <- merge(tr2, events, by="d")

# Make a tsibble of the data frame
tr2 <- tr2 %>%
  as_tsibble(
    index = d
    )

# Plot
tr2 %>% autoplot(rowMean)

# Fit the training data
fit2 <- tr2 %>% 
  model(
    trend_model = TSLM(rowMean ~ trend()),
    MEAN = MEAN(rowMean),
    NAIVE = NAIVE(rowMean),
    SNAIVE = SNAIVE(rowMean),
    Drift = RW(rowMean ~ drift()),
    arima = ARIMA(rowMean)
  )

# Get the accuracy
fit2 %>% accuracy()

```
For the second cluster ARIMA is also the best model.

# Get the products of cluster 2
Best model for cluster2 is ARIMA model.
```{r}
# Get the products from cluster 2
new <- transpose(NC2)
products2 <- tibble::rownames_to_column(new, "Products")
products2 <- products2['Products']; products2

```

# Cluster 3
```{r}
# Get the number of events per month per year
event3 <- test3 %>%
  select(year, month, event_name_1, event_type_1, event_name_2, event_type_2) %>%
  mutate(
    event = if_else((event_name_1 != "" | event_type_1 != "" | event_name_2 != "" | event_type_2 != ""), 1, 0)
  ) %>%
  group_by(year, month) %>%
  summarise(event = sum(event))

# Keep certain columns
newC3 <- subset(test3, select = -c(date,wm_yr_wk,weekday,wday,event_name_1, event_type_1,event_name_2,event_type_2, snap_CA))
NC3 <- merge(newC3, event3)
NC3 <- subset(NC3, select=-c(month, year, group_id))

# Make an event data frame
events3 <- subset(NC3, select=event)
events3 <- tibble::rownames_to_column(events3, "d")

# Keep only the products
NC3 <- subset(NC3, select=-c(event))
rownames(NC3) <- NC3$d
NC3 <- subset(NC3, select = -c(d))

#get all columns that are of type character
factor_columns <- sapply(NC3, is.character)

#change them from type factor to numeric so the numeric data can be plotted 
NC3[factor_columns] <- lapply(NC3[factor_columns], function(x) as.numeric(as.character(x))) 

# Get the mean of sales per day
train3 <- NC3 %>% mutate('rowMean' = rowMeans(NC3))
train3 <- subset(train3, select = rowMean)

tr3 <- tibble::rownames_to_column(train3, "d")
tr3
#get all columns that are of type character
#factor_columns <- sapply(tr3, is.character)

#change them from type factor to numeric so the numeric data can be plotted 
#tr3[factor_columns] <- lapply(tr3[factor_columns], function(x) as.numeric(as.character(x)))

# Add events to the rowMeans
tr3 <- merge(tr3, events3, by="d")
tr3
# Make a tsibble of the data frame
tr3 <- tr3 %>%
  as_tsibble(
    index = d
    )

# Plot
tr3 %>% autoplot(rowMean)

# Fit the training data
fit3 <- tr3 %>% 
  model(
    trend_model = TSLM(rowMean ~ trend()),
    MEAN = MEAN(rowMean),
    NAIVE = NAIVE(rowMean),
    SNAIVE = SNAIVE(rowMean),
    Drift = RW(rowMean ~ drift()),
    arima = ARIMA(rowMean)
  )

# Get the accuracy
fit3 %>% accuracy()

```


# Get the products of cluster 3
Best model for cluster3 is ARIMA model.
```{r}
# Get the products from cluster 3
new <- transpose(NC3)
products3 <- tibble::rownames_to_column(new, "Products")

products3 <- products3['Products']; products3

```



# TEST DOESN'T WORK YET


```{r}
trainNew

for (i in nrow(products1)){
  product <- products1[i,]
  df <- trainNew[product]
  df <- tibble::rownames_to_column(df, "d")
  
  # Get the id of the date
  df<-mutate(df,d=as.character(d))
  df<-mutate(df,d=sapply(strsplit(df$d, split='_', fixed=TRUE),function(x) (x[2])))
  df<-mutate(df,d=as.numeric(d))
  df

  # Make a tsibble of the data frame
  tr1 <- df %>%
  as_tsibble(
    index = d
    )
  tr1
  
  print(names(tr1)[2])
  fit <- tr1 %>% model(RW(FOODS_3_607_TX_3_validation ~ drift()))
  fit %>% forecast(h=28) %>% autoplot(df)
}


```


